<div style="font-family: ui-monospace, 'SF Mono', 'Menlo', 'Monaco', 'Cascadia Mono', 'Consolas', monospace; font-size: 14px; line-height: 1.5; color: #4c4f69; text-align: left;"><p style="margin: 8px 0;">In JavaScript, objects stay in memory as long as something still references them (globals, active stack frames, or long-lived registries like event listener lists / timer queues), which can lead to {{c1::memory leaks}}.</p><p style="margin: 8px 0;">setTimeout and addEventListener are examples of {{c2::strong}} references to functions, so the function can’t be {{c3::GC’d}}. If the function is a closure, it also retains its {{c4::lexical environment / captured bindings::what closures keep}}, which can accidentally keep large request-scoped objects alive (e.g. {{c5::request body / init / options / this / other big objects in scope::examples}}) for as long as the callback remains referenced.</p><p style="margin: 8px 0;">Key mental model: a “leak” is often a callback that outlives {{c6::the request it was created for}}, because the callback is registered somewhere long-lived.</p><p style="margin: 8px 0;">In this diff, the original code created fresh arrow functions:</p><p style="margin: 8px 0;"></p><pre style="background: #eff1f5; padding: 12px 16px; border-radius: 8px; overflow-x: auto; margin: 8px 0;"><code style="font-family: ui-monospace, 'SF Mono', 'Menlo', 'Monaco', 'Cascadia Mono', 'Consolas', monospace; font-size: 14px;"><span ><span style="color:#8839EF">if</span><span style="color:#4C4F69"> (signal) signal</span><span style="color:#179299">.</span><span style="color:#1E66F5;font-style:italic">addEventListener</span><span style="color:#4C4F69">(</span><span style="color:#40A02B">'abort'</span><span style="color:#7C7F93">,</span><span style="color:#7C7F93"> ()</span><span style="color:#179299"> =></span><span style="color:#4C4F69"> controller</span><span style="color:#179299">.</span><span style="color:#1E66F5;font-style:italic">abort</span><span style="color:#4C4F69">())</span><span style="color:#7C7F93">;</span></span>
<span ><span style="color:#8839EF">const</span><span style="color:#4C4F69"> timeout </span><span style="color:#179299">=</span><span style="color:#1E66F5;font-style:italic"> setTimeout</span><span style="color:#4C4F69">(</span><span style="color:#7C7F93">()</span><span style="color:#179299"> =></span><span style="color:#4C4F69"> controller</span><span style="color:#179299">.</span><span style="color:#1E66F5;font-style:italic">abort</span><span style="color:#4C4F69">()</span><span style="color:#7C7F93">,</span><span style="color:#4C4F69"> ms)</span><span style="color:#7C7F93">;</span></span>
<span ></span></code></pre><p style="margin: 8px 0;"></p><p style="margin: 8px 0;">Problem setup: when the user passes a {{c7::long-lived AbortSignal::kind of signal}}, the signal keeps a reference to the listener callback {{c8::forever unless removed::listener lifetime}}. Even though AbortSignal’s "abort" fires {{c9::at most once::how many times}}, the listener can still remain in the signal’s listener list if you don’t remove it (dead weight). Across many requests, that piles up into {{c10::lots of unreachable-to-you but still-reachable-to-GC callbacks::what accumulates}}, and if those callbacks retain big scopes, you can see {{c11::huge memory growth (e.g. ~1GB in very long sessions)::symptom}}.</p><p style="margin: 8px 0;">The fix did two orthogonal things: (1) {{c12::bound callback instead of arrow closure::technique}} and (2) {{c13::auto-unsubscribe after first run::lifetime control}}.</p><p style="margin: 8px 0;"></p><pre style="background: #eff1f5; padding: 12px 16px; border-radius: 8px; overflow-x: auto; margin: 8px 0;"><code style="font-family: ui-monospace, 'SF Mono', 'Menlo', 'Monaco', 'Cascadia Mono', 'Consolas', monospace; font-size: 14px;"><span ><span style="color:#8839EF">const</span><span style="color:#4C4F69"> abort </span><span style="color:#179299">=</span><span style="color:#4C4F69"> {{c14::controller</span><span style="color:#179299">.</span><span style="color:#4C4F69">abort</span><span style="color:#179299">.</span><span style="color:#1E66F5;font-style:italic">bind</span><span style="color:#4C4F69">(controller)</span><span style="color:#7C7F93">;</span><span style="color:#4C4F69">}}</span></span>
<span ><span style="color:#8839EF">if</span><span style="color:#4C4F69"> (signal) {{c15::signal</span><span style="color:#179299">.</span><span style="color:#1E66F5;font-style:italic">addEventListener</span><span style="color:#4C4F69">(</span><span style="color:#40A02B">'abort'</span><span style="color:#7C7F93">,</span><span style="color:#4C4F69"> abort</span><span style="color:#7C7F93">,</span><span style="color:#7C7F93"> {</span><span style="color:#4C4F69"> once</span><span style="color:#179299">:</span><span style="color:#FE640B"> true</span><span style="color:#7C7F93"> }</span><span style="color:#4C4F69">)</span><span style="color:#7C7F93">;</span><span style="color:#4C4F69">}}</span></span>
<span ></span>
<span ><span style="color:#8839EF">const</span><span style="color:#4C4F69"> timeout </span><span style="color:#179299">=</span><span style="color:#4C4F69"> {{c16::</span><span style="color:#1E66F5;font-style:italic">setTimeout</span><span style="color:#4C4F69">(abort</span><span style="color:#7C7F93">,</span><span style="color:#4C4F69"> ms)}}</span><span style="color:#7C7F93">;</span></span>
<span ></span></code></pre><p style="margin: 8px 0;"></p><p style="margin: 8px 0;">Why {{c17::{ once: true }::option}} matters: it ensures the event listener is removed automatically after it runs once</p><p style="margin: 8px 0;">Why {{c18::.bind(controller)::method}} still matters: it creates a callback whose retained graph is much {{c19::smaller::size}}.</p></div>